// Code generated by goagen v1.2.0, DO NOT EDIT.
//
// API "Iroha-Gateway Server": Application User Types
//
// Command:
// $ goagen
// --design=github.com/soramitsu/iroha-gateway/design
// --out=$(GOPATH)/src/github.com/soramitsu/iroha-gateway
// --version=v1.2.0

package app

import (
	"github.com/goadesign/goa"
)

// accountPayload user type.
type accountPayload struct {
	// Minimum number of signatures required to issue valid transaction.
	Quorum *int `form:"quorum,omitempty" json:"quorum,omitempty" xml:"quorum,omitempty"`
	// Account signatories.
	Signatories []string `form:"signatories,omitempty" json:"signatories,omitempty" xml:"signatories,omitempty"`
	// account's username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// account's guid
	UUID *string `form:"uuid,omitempty" json:"uuid,omitempty" xml:"uuid,omitempty"`
}

// Validate validates the accountPayload type instance.
func (ut *accountPayload) Validate() (err error) {
	if ut.UUID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "uuid"))
	}
	if ut.Signatories == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signatories"))
	}
	if ut.Quorum == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "quorum"))
	}
	if ut.Quorum != nil {
		if *ut.Quorum < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`response.quorum`, *ut.Quorum, 1, true))
		}
	}
	if ut.Quorum != nil {
		if *ut.Quorum > 32 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`response.quorum`, *ut.Quorum, 32, false))
		}
	}
	if ut.Username != nil {
		if ok := goa.ValidatePattern(`^[a-zA-Z0-9\_\-\.]{4,32}$`, *ut.Username); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.username`, *ut.Username, `^[a-zA-Z0-9\_\-\.]{4,32}$`))
		}
	}
	if ut.UUID != nil {
		if ok := goa.ValidatePattern(`^[0-9a-f-]{32}$`, *ut.UUID); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.uuid`, *ut.UUID, `^[0-9a-f-]{32}$`))
		}
	}
	return
}

// Publicize creates AccountPayload from accountPayload
func (ut *accountPayload) Publicize() *AccountPayload {
	var pub AccountPayload
	if ut.Quorum != nil {
		pub.Quorum = *ut.Quorum
	}
	if ut.Signatories != nil {
		pub.Signatories = ut.Signatories
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	if ut.UUID != nil {
		pub.UUID = *ut.UUID
	}
	return &pub
}

// AccountPayload user type.
type AccountPayload struct {
	// Minimum number of signatures required to issue valid transaction.
	Quorum int `form:"quorum" json:"quorum" xml:"quorum"`
	// Account signatories.
	Signatories []string `form:"signatories" json:"signatories" xml:"signatories"`
	// account's username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// account's guid
	UUID string `form:"uuid" json:"uuid" xml:"uuid"`
}

// Validate validates the AccountPayload type instance.
func (ut *AccountPayload) Validate() (err error) {
	if ut.UUID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "uuid"))
	}
	if ut.Signatories == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signatories"))
	}

	if ut.Quorum < 1 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.quorum`, ut.Quorum, 1, true))
	}
	if ut.Quorum > 32 {
		err = goa.MergeErrors(err, goa.InvalidRangeError(`response.quorum`, ut.Quorum, 32, false))
	}
	if ut.Username != nil {
		if ok := goa.ValidatePattern(`^[a-zA-Z0-9\_\-\.]{4,32}$`, *ut.Username); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.username`, *ut.Username, `^[a-zA-Z0-9\_\-\.]{4,32}$`))
		}
	}
	if ok := goa.ValidatePattern(`^[0-9a-f-]{32}$`, ut.UUID); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.uuid`, ut.UUID, `^[0-9a-f-]{32}$`))
	}
	return
}

// addAccountRequest user type.
type addAccountRequest struct {
	Account         *accountPayload     `form:"account,omitempty" json:"account,omitempty" xml:"account,omitempty"`
	MetaTransaction *transactionRequest `form:"meta_transaction,omitempty" json:"meta_transaction,omitempty" xml:"meta_transaction,omitempty"`
}

// Validate validates the addAccountRequest type instance.
func (ut *addAccountRequest) Validate() (err error) {
	if ut.MetaTransaction == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "meta_transaction"))
	}
	if ut.Account == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "account"))
	}
	if ut.Account != nil {
		if err2 := ut.Account.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.MetaTransaction != nil {
		if err2 := ut.MetaTransaction.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates AddAccountRequest from addAccountRequest
func (ut *addAccountRequest) Publicize() *AddAccountRequest {
	var pub AddAccountRequest
	if ut.Account != nil {
		pub.Account = ut.Account.Publicize()
	}
	if ut.MetaTransaction != nil {
		pub.MetaTransaction = ut.MetaTransaction.Publicize()
	}
	return &pub
}

// AddAccountRequest user type.
type AddAccountRequest struct {
	Account         *AccountPayload     `form:"account" json:"account" xml:"account"`
	MetaTransaction *TransactionRequest `form:"meta_transaction" json:"meta_transaction" xml:"meta_transaction"`
}

// Validate validates the AddAccountRequest type instance.
func (ut *AddAccountRequest) Validate() (err error) {
	if ut.MetaTransaction == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "meta_transaction"))
	}
	if ut.Account == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "account"))
	}
	if ut.Account != nil {
		if err2 := ut.Account.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.MetaTransaction != nil {
		if err2 := ut.MetaTransaction.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// createCurrencyRequest user type.
type createCurrencyRequest struct {
	// Public key of creator's account
	CreatorPubkey *string          `form:"creator_pubkey,omitempty" json:"creator_pubkey,omitempty" xml:"creator_pubkey,omitempty"`
	Currency      *currencyPayload `form:"currency,omitempty" json:"currency,omitempty" xml:"currency,omitempty"`
	// The signature, which can be verified with pubkey
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
	// Public key of URL-encoded target's account
	Target *string `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
	// Transaction timestamp
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

// Validate validates the createCurrencyRequest type instance.
func (ut *createCurrencyRequest) Validate() (err error) {
	if ut.Target == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "target"))
	}
	if ut.CreatorPubkey == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ut.Currency == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "currency"))
	}
	if ut.Currency != nil {
		if err2 := ut.Currency.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Target != nil {
		if ok := goa.ValidatePattern(`[0-9a-zA-Z-_.~]+`, *ut.Target); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.target`, *ut.Target, `[0-9a-zA-Z-_.~]+`))
		}
	}
	if ut.Timestamp != nil {
		if ok := goa.ValidatePattern(`[0-9]{1,18}`, *ut.Timestamp); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, *ut.Timestamp, `[0-9]{1,18}`))
		}
	}
	return
}

// Publicize creates CreateCurrencyRequest from createCurrencyRequest
func (ut *createCurrencyRequest) Publicize() *CreateCurrencyRequest {
	var pub CreateCurrencyRequest
	if ut.CreatorPubkey != nil {
		pub.CreatorPubkey = *ut.CreatorPubkey
	}
	if ut.Currency != nil {
		pub.Currency = ut.Currency.Publicize()
	}
	if ut.Signature != nil {
		pub.Signature = *ut.Signature
	}
	if ut.Target != nil {
		pub.Target = *ut.Target
	}
	if ut.Timestamp != nil {
		pub.Timestamp = *ut.Timestamp
	}
	return &pub
}

// CreateCurrencyRequest user type.
type CreateCurrencyRequest struct {
	// Public key of creator's account
	CreatorPubkey string           `form:"creator_pubkey" json:"creator_pubkey" xml:"creator_pubkey"`
	Currency      *CurrencyPayload `form:"currency" json:"currency" xml:"currency"`
	// The signature, which can be verified with pubkey
	Signature string `form:"signature" json:"signature" xml:"signature"`
	// Public key of URL-encoded target's account
	Target string `form:"target" json:"target" xml:"target"`
	// Transaction timestamp
	Timestamp string `form:"timestamp" json:"timestamp" xml:"timestamp"`
}

// Validate validates the CreateCurrencyRequest type instance.
func (ut *CreateCurrencyRequest) Validate() (err error) {
	if ut.Target == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "target"))
	}
	if ut.CreatorPubkey == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ut.Currency == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "currency"))
	}
	if ut.Currency != nil {
		if err2 := ut.Currency.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ok := goa.ValidatePattern(`[0-9a-zA-Z-_.~]+`, ut.Target); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.target`, ut.Target, `[0-9a-zA-Z-_.~]+`))
	}
	if ok := goa.ValidatePattern(`[0-9]{1,18}`, ut.Timestamp); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, ut.Timestamp, `[0-9]{1,18}`))
	}
	return
}

// currencyPayload user type.
type currencyPayload struct {
	// currency's description
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// domain name to which currency belongs
	DomainName *string `form:"domain_name,omitempty" json:"domain_name,omitempty" xml:"domain_name,omitempty"`
	// ledger name to which currency belongs
	LedgerName *string `form:"ledger_name,omitempty" json:"ledger_name,omitempty" xml:"ledger_name,omitempty"`
	// currency name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// currency's value
	Value *float64 `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
}

// Validate validates the currencyPayload type instance.
func (ut *currencyPayload) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}
	if ut.DomainName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "domain_name"))
	}
	if ut.LedgerName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ledger_name"))
	}
	if ut.Value == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "value"))
	}
	return
}

// Publicize creates CurrencyPayload from currencyPayload
func (ut *currencyPayload) Publicize() *CurrencyPayload {
	var pub CurrencyPayload
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.DomainName != nil {
		pub.DomainName = *ut.DomainName
	}
	if ut.LedgerName != nil {
		pub.LedgerName = *ut.LedgerName
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.Value != nil {
		pub.Value = *ut.Value
	}
	return &pub
}

// CurrencyPayload user type.
type CurrencyPayload struct {
	// currency's description
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// domain name to which currency belongs
	DomainName string `form:"domain_name" json:"domain_name" xml:"domain_name"`
	// ledger name to which currency belongs
	LedgerName string `form:"ledger_name" json:"ledger_name" xml:"ledger_name"`
	// currency name
	Name string `form:"name" json:"name" xml:"name"`
	// currency's value
	Value float64 `form:"value" json:"value" xml:"value"`
}

// Validate validates the CurrencyPayload type instance.
func (ut *CurrencyPayload) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "name"))
	}
	if ut.DomainName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "domain_name"))
	}
	if ut.LedgerName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ledger_name"))
	}

	return
}

// currencyTransferRequest user type.
type currencyTransferRequest struct {
	// Public key of creator's account
	CreatorPubkey *string `form:"creator_pubkey,omitempty" json:"creator_pubkey,omitempty" xml:"creator_pubkey,omitempty"`
	// receiver's public key
	Receiver *string `form:"receiver,omitempty" json:"receiver,omitempty" xml:"receiver,omitempty"`
	// sender's public key
	Sender *string `form:"sender,omitempty" json:"sender,omitempty" xml:"sender,omitempty"`
	// The signature, which can be verified with pubkey
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
	// Public key of URL-encoded target's account
	Target *string `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
	// Transaction timestamp
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
	// currency's value
	Value *float64 `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
}

// Validate validates the currencyTransferRequest type instance.
func (ut *currencyTransferRequest) Validate() (err error) {
	if ut.Value == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "value"))
	}
	if ut.Sender == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "sender"))
	}
	if ut.Receiver == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "receiver"))
	}
	if ut.Target == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "target"))
	}
	if ut.CreatorPubkey == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ut.Receiver != nil {
		if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, *ut.Receiver); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.receiver`, *ut.Receiver, `^[0-9a-zA-Z+/=]+$`))
		}
	}
	if ut.Sender != nil {
		if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, *ut.Sender); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.sender`, *ut.Sender, `^[0-9a-zA-Z+/=]+$`))
		}
	}
	if ut.Target != nil {
		if ok := goa.ValidatePattern(`[0-9a-zA-Z-_.~]+`, *ut.Target); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.target`, *ut.Target, `[0-9a-zA-Z-_.~]+`))
		}
	}
	if ut.Timestamp != nil {
		if ok := goa.ValidatePattern(`[0-9]{1,18}`, *ut.Timestamp); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, *ut.Timestamp, `[0-9]{1,18}`))
		}
	}
	return
}

// Publicize creates CurrencyTransferRequest from currencyTransferRequest
func (ut *currencyTransferRequest) Publicize() *CurrencyTransferRequest {
	var pub CurrencyTransferRequest
	if ut.CreatorPubkey != nil {
		pub.CreatorPubkey = *ut.CreatorPubkey
	}
	if ut.Receiver != nil {
		pub.Receiver = *ut.Receiver
	}
	if ut.Sender != nil {
		pub.Sender = *ut.Sender
	}
	if ut.Signature != nil {
		pub.Signature = *ut.Signature
	}
	if ut.Target != nil {
		pub.Target = *ut.Target
	}
	if ut.Timestamp != nil {
		pub.Timestamp = *ut.Timestamp
	}
	if ut.Value != nil {
		pub.Value = *ut.Value
	}
	return &pub
}

// CurrencyTransferRequest user type.
type CurrencyTransferRequest struct {
	// Public key of creator's account
	CreatorPubkey string `form:"creator_pubkey" json:"creator_pubkey" xml:"creator_pubkey"`
	// receiver's public key
	Receiver string `form:"receiver" json:"receiver" xml:"receiver"`
	// sender's public key
	Sender string `form:"sender" json:"sender" xml:"sender"`
	// The signature, which can be verified with pubkey
	Signature string `form:"signature" json:"signature" xml:"signature"`
	// Public key of URL-encoded target's account
	Target string `form:"target" json:"target" xml:"target"`
	// Transaction timestamp
	Timestamp string `form:"timestamp" json:"timestamp" xml:"timestamp"`
	// currency's value
	Value float64 `form:"value" json:"value" xml:"value"`
}

// Validate validates the CurrencyTransferRequest type instance.
func (ut *CurrencyTransferRequest) Validate() (err error) {

	if ut.Sender == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "sender"))
	}
	if ut.Receiver == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "receiver"))
	}
	if ut.Target == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "target"))
	}
	if ut.CreatorPubkey == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, ut.Receiver); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.receiver`, ut.Receiver, `^[0-9a-zA-Z+/=]+$`))
	}
	if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, ut.Sender); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.sender`, ut.Sender, `^[0-9a-zA-Z+/=]+$`))
	}
	if ok := goa.ValidatePattern(`[0-9a-zA-Z-_.~]+`, ut.Target); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.target`, ut.Target, `[0-9a-zA-Z-_.~]+`))
	}
	if ok := goa.ValidatePattern(`[0-9]{1,18}`, ut.Timestamp); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, ut.Timestamp, `[0-9]{1,18}`))
	}
	return
}

// currencyValueRequest user type.
type currencyValueRequest struct {
	// Public key of creator's account
	CreatorPubkey *string `form:"creator_pubkey,omitempty" json:"creator_pubkey,omitempty" xml:"creator_pubkey,omitempty"`
	// The signature, which can be verified with pubkey
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
	// Public key of URL-encoded target's account
	Target *string `form:"target,omitempty" json:"target,omitempty" xml:"target,omitempty"`
	// Transaction timestamp
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
	// currency's value
	Value *float64 `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
}

// Validate validates the currencyValueRequest type instance.
func (ut *currencyValueRequest) Validate() (err error) {
	if ut.Value == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "value"))
	}
	if ut.Target == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "target"))
	}
	if ut.CreatorPubkey == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ut.Target != nil {
		if ok := goa.ValidatePattern(`[0-9a-zA-Z-_.~]+`, *ut.Target); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.target`, *ut.Target, `[0-9a-zA-Z-_.~]+`))
		}
	}
	if ut.Timestamp != nil {
		if ok := goa.ValidatePattern(`[0-9]{1,18}`, *ut.Timestamp); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, *ut.Timestamp, `[0-9]{1,18}`))
		}
	}
	return
}

// Publicize creates CurrencyValueRequest from currencyValueRequest
func (ut *currencyValueRequest) Publicize() *CurrencyValueRequest {
	var pub CurrencyValueRequest
	if ut.CreatorPubkey != nil {
		pub.CreatorPubkey = *ut.CreatorPubkey
	}
	if ut.Signature != nil {
		pub.Signature = *ut.Signature
	}
	if ut.Target != nil {
		pub.Target = *ut.Target
	}
	if ut.Timestamp != nil {
		pub.Timestamp = *ut.Timestamp
	}
	if ut.Value != nil {
		pub.Value = *ut.Value
	}
	return &pub
}

// CurrencyValueRequest user type.
type CurrencyValueRequest struct {
	// Public key of creator's account
	CreatorPubkey string `form:"creator_pubkey" json:"creator_pubkey" xml:"creator_pubkey"`
	// The signature, which can be verified with pubkey
	Signature string `form:"signature" json:"signature" xml:"signature"`
	// Public key of URL-encoded target's account
	Target string `form:"target" json:"target" xml:"target"`
	// Transaction timestamp
	Timestamp string `form:"timestamp" json:"timestamp" xml:"timestamp"`
	// currency's value
	Value float64 `form:"value" json:"value" xml:"value"`
}

// Validate validates the CurrencyValueRequest type instance.
func (ut *CurrencyValueRequest) Validate() (err error) {

	if ut.Target == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "target"))
	}
	if ut.CreatorPubkey == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ok := goa.ValidatePattern(`[0-9a-zA-Z-_.~]+`, ut.Target); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.target`, ut.Target, `[0-9a-zA-Z-_.~]+`))
	}
	if ok := goa.ValidatePattern(`[0-9]{1,18}`, ut.Timestamp); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, ut.Timestamp, `[0-9]{1,18}`))
	}
	return
}

// deleteAccountRequest user type.
type deleteAccountRequest struct {
	MetaTransaction *transactionRequest `form:"meta_transaction,omitempty" json:"meta_transaction,omitempty" xml:"meta_transaction,omitempty"`
}

// Validate validates the deleteAccountRequest type instance.
func (ut *deleteAccountRequest) Validate() (err error) {
	if ut.MetaTransaction == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "meta_transaction"))
	}
	if ut.MetaTransaction != nil {
		if err2 := ut.MetaTransaction.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates DeleteAccountRequest from deleteAccountRequest
func (ut *deleteAccountRequest) Publicize() *DeleteAccountRequest {
	var pub DeleteAccountRequest
	if ut.MetaTransaction != nil {
		pub.MetaTransaction = ut.MetaTransaction.Publicize()
	}
	return &pub
}

// DeleteAccountRequest user type.
type DeleteAccountRequest struct {
	MetaTransaction *TransactionRequest `form:"meta_transaction" json:"meta_transaction" xml:"meta_transaction"`
}

// Validate validates the DeleteAccountRequest type instance.
func (ut *DeleteAccountRequest) Validate() (err error) {
	if ut.MetaTransaction == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "meta_transaction"))
	}
	if ut.MetaTransaction != nil {
		if err2 := ut.MetaTransaction.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// deleteCurrencyRequest user type.
type deleteCurrencyRequest struct {
	// Public key of creator's account
	CreatorPubkey *string `form:"creator_pubkey,omitempty" json:"creator_pubkey,omitempty" xml:"creator_pubkey,omitempty"`
	// The signature, which can be verified with pubkey
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
	// Transaction timestamp
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

// Validate validates the deleteCurrencyRequest type instance.
func (ut *deleteCurrencyRequest) Validate() (err error) {
	if ut.CreatorPubkey == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ut.Timestamp != nil {
		if ok := goa.ValidatePattern(`[0-9]{1,18}`, *ut.Timestamp); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, *ut.Timestamp, `[0-9]{1,18}`))
		}
	}
	return
}

// Publicize creates DeleteCurrencyRequest from deleteCurrencyRequest
func (ut *deleteCurrencyRequest) Publicize() *DeleteCurrencyRequest {
	var pub DeleteCurrencyRequest
	if ut.CreatorPubkey != nil {
		pub.CreatorPubkey = *ut.CreatorPubkey
	}
	if ut.Signature != nil {
		pub.Signature = *ut.Signature
	}
	if ut.Timestamp != nil {
		pub.Timestamp = *ut.Timestamp
	}
	return &pub
}

// DeleteCurrencyRequest user type.
type DeleteCurrencyRequest struct {
	// Public key of creator's account
	CreatorPubkey string `form:"creator_pubkey" json:"creator_pubkey" xml:"creator_pubkey"`
	// The signature, which can be verified with pubkey
	Signature string `form:"signature" json:"signature" xml:"signature"`
	// Transaction timestamp
	Timestamp string `form:"timestamp" json:"timestamp" xml:"timestamp"`
}

// Validate validates the DeleteCurrencyRequest type instance.
func (ut *DeleteCurrencyRequest) Validate() (err error) {
	if ut.CreatorPubkey == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ok := goa.ValidatePattern(`[0-9]{1,18}`, ut.Timestamp); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, ut.Timestamp, `[0-9]{1,18}`))
	}
	return
}

// deleteSignatoryRequest user type.
type deleteSignatoryRequest struct {
	// Public key of creator's account
	CreatorPubkey *string `form:"creator_pubkey,omitempty" json:"creator_pubkey,omitempty" xml:"creator_pubkey,omitempty"`
	// The signature, which can be verified with pubkey
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
	// Transaction timestamp
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

// Validate validates the deleteSignatoryRequest type instance.
func (ut *deleteSignatoryRequest) Validate() (err error) {
	if ut.CreatorPubkey == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ut.Timestamp != nil {
		if ok := goa.ValidatePattern(`[0-9]{1,18}`, *ut.Timestamp); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, *ut.Timestamp, `[0-9]{1,18}`))
		}
	}
	return
}

// Publicize creates DeleteSignatoryRequest from deleteSignatoryRequest
func (ut *deleteSignatoryRequest) Publicize() *DeleteSignatoryRequest {
	var pub DeleteSignatoryRequest
	if ut.CreatorPubkey != nil {
		pub.CreatorPubkey = *ut.CreatorPubkey
	}
	if ut.Signature != nil {
		pub.Signature = *ut.Signature
	}
	if ut.Timestamp != nil {
		pub.Timestamp = *ut.Timestamp
	}
	return &pub
}

// DeleteSignatoryRequest user type.
type DeleteSignatoryRequest struct {
	// Public key of creator's account
	CreatorPubkey string `form:"creator_pubkey" json:"creator_pubkey" xml:"creator_pubkey"`
	// The signature, which can be verified with pubkey
	Signature string `form:"signature" json:"signature" xml:"signature"`
	// Transaction timestamp
	Timestamp string `form:"timestamp" json:"timestamp" xml:"timestamp"`
}

// Validate validates the DeleteSignatoryRequest type instance.
func (ut *DeleteSignatoryRequest) Validate() (err error) {
	if ut.CreatorPubkey == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ok := goa.ValidatePattern(`[0-9]{1,18}`, ut.Timestamp); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, ut.Timestamp, `[0-9]{1,18}`))
	}
	return
}

// permissionAsset user type.
type permissionAsset struct {
	// ability to give permissions to account globally
	AccountGivePermission *bool `form:"account_give_permission,omitempty" json:"account_give_permission,omitempty" xml:"account_give_permission,omitempty"`
	// ability to add some amount to account
	Add *bool `form:"add,omitempty" json:"add,omitempty" xml:"add,omitempty"`
	// asset name
	AssetName *string `form:"asset_name,omitempty" json:"asset_name,omitempty" xml:"asset_name,omitempty"`
	// domain name
	DomainName *string `form:"domain_name,omitempty" json:"domain_name,omitempty" xml:"domain_name,omitempty"`
	// ledger name
	LedgerName *string `form:"ledger_name,omitempty" json:"ledger_name,omitempty" xml:"ledger_name,omitempty"`
	// ability to access some amount from account
	Read *bool `form:"read,omitempty" json:"read,omitempty" xml:"read,omitempty"`
	// ability to remove some amount from account
	Subtract *bool `form:"subtract,omitempty" json:"subtract,omitempty" xml:"subtract,omitempty"`
	// ability to transfer an asset
	Transfer *bool `form:"transfer,omitempty" json:"transfer,omitempty" xml:"transfer,omitempty"`
}

// Validate validates the permissionAsset type instance.
func (ut *permissionAsset) Validate() (err error) {
	if ut.AssetName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "asset_name"))
	}
	if ut.DomainName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "domain_name"))
	}
	if ut.LedgerName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ledger_name"))
	}
	return
}

// Publicize creates PermissionAsset from permissionAsset
func (ut *permissionAsset) Publicize() *PermissionAsset {
	var pub PermissionAsset
	if ut.AccountGivePermission != nil {
		pub.AccountGivePermission = ut.AccountGivePermission
	}
	if ut.Add != nil {
		pub.Add = ut.Add
	}
	if ut.AssetName != nil {
		pub.AssetName = *ut.AssetName
	}
	if ut.DomainName != nil {
		pub.DomainName = *ut.DomainName
	}
	if ut.LedgerName != nil {
		pub.LedgerName = *ut.LedgerName
	}
	if ut.Read != nil {
		pub.Read = ut.Read
	}
	if ut.Subtract != nil {
		pub.Subtract = ut.Subtract
	}
	if ut.Transfer != nil {
		pub.Transfer = ut.Transfer
	}
	return &pub
}

// PermissionAsset user type.
type PermissionAsset struct {
	// ability to give permissions to account globally
	AccountGivePermission *bool `form:"account_give_permission,omitempty" json:"account_give_permission,omitempty" xml:"account_give_permission,omitempty"`
	// ability to add some amount to account
	Add *bool `form:"add,omitempty" json:"add,omitempty" xml:"add,omitempty"`
	// asset name
	AssetName string `form:"asset_name" json:"asset_name" xml:"asset_name"`
	// domain name
	DomainName string `form:"domain_name" json:"domain_name" xml:"domain_name"`
	// ledger name
	LedgerName string `form:"ledger_name" json:"ledger_name" xml:"ledger_name"`
	// ability to access some amount from account
	Read *bool `form:"read,omitempty" json:"read,omitempty" xml:"read,omitempty"`
	// ability to remove some amount from account
	Subtract *bool `form:"subtract,omitempty" json:"subtract,omitempty" xml:"subtract,omitempty"`
	// ability to transfer an asset
	Transfer *bool `form:"transfer,omitempty" json:"transfer,omitempty" xml:"transfer,omitempty"`
}

// Validate validates the PermissionAsset type instance.
func (ut *PermissionAsset) Validate() (err error) {
	if ut.AssetName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "asset_name"))
	}
	if ut.DomainName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "domain_name"))
	}
	if ut.LedgerName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ledger_name"))
	}
	return
}

// permissionDomain user type.
type permissionDomain struct {
	// ability to create new account
	AccountAdd *bool `form:"account_add,omitempty" json:"account_add,omitempty" xml:"account_add,omitempty"`
	// ability to give permissions to account globally
	AccountGivePermission *bool `form:"account_give_permission,omitempty" json:"account_give_permission,omitempty" xml:"account_give_permission,omitempty"`
	// ability to remove account
	AccountRemove *bool `form:"account_remove,omitempty" json:"account_remove,omitempty" xml:"account_remove,omitempty"`
	// ability to create asset
	AssetCreate *bool `form:"asset_create,omitempty" json:"asset_create,omitempty" xml:"asset_create,omitempty"`
	// ability to remove asset
	AssetRemove *bool `form:"asset_remove,omitempty" json:"asset_remove,omitempty" xml:"asset_remove,omitempty"`
	// ability to update asset
	AssetUpdate *bool `form:"asset_update,omitempty" json:"asset_update,omitempty" xml:"asset_update,omitempty"`
	// domain name
	DomainName *string `form:"domain_name,omitempty" json:"domain_name,omitempty" xml:"domain_name,omitempty"`
	// ledger name
	LedgerName *string `form:"ledger_name,omitempty" json:"ledger_name,omitempty" xml:"ledger_name,omitempty"`
}

// Validate validates the permissionDomain type instance.
func (ut *permissionDomain) Validate() (err error) {
	if ut.DomainName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "domain_name"))
	}
	if ut.LedgerName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ledger_name"))
	}
	return
}

// Publicize creates PermissionDomain from permissionDomain
func (ut *permissionDomain) Publicize() *PermissionDomain {
	var pub PermissionDomain
	if ut.AccountAdd != nil {
		pub.AccountAdd = ut.AccountAdd
	}
	if ut.AccountGivePermission != nil {
		pub.AccountGivePermission = ut.AccountGivePermission
	}
	if ut.AccountRemove != nil {
		pub.AccountRemove = ut.AccountRemove
	}
	if ut.AssetCreate != nil {
		pub.AssetCreate = ut.AssetCreate
	}
	if ut.AssetRemove != nil {
		pub.AssetRemove = ut.AssetRemove
	}
	if ut.AssetUpdate != nil {
		pub.AssetUpdate = ut.AssetUpdate
	}
	if ut.DomainName != nil {
		pub.DomainName = *ut.DomainName
	}
	if ut.LedgerName != nil {
		pub.LedgerName = *ut.LedgerName
	}
	return &pub
}

// PermissionDomain user type.
type PermissionDomain struct {
	// ability to create new account
	AccountAdd *bool `form:"account_add,omitempty" json:"account_add,omitempty" xml:"account_add,omitempty"`
	// ability to give permissions to account globally
	AccountGivePermission *bool `form:"account_give_permission,omitempty" json:"account_give_permission,omitempty" xml:"account_give_permission,omitempty"`
	// ability to remove account
	AccountRemove *bool `form:"account_remove,omitempty" json:"account_remove,omitempty" xml:"account_remove,omitempty"`
	// ability to create asset
	AssetCreate *bool `form:"asset_create,omitempty" json:"asset_create,omitempty" xml:"asset_create,omitempty"`
	// ability to remove asset
	AssetRemove *bool `form:"asset_remove,omitempty" json:"asset_remove,omitempty" xml:"asset_remove,omitempty"`
	// ability to update asset
	AssetUpdate *bool `form:"asset_update,omitempty" json:"asset_update,omitempty" xml:"asset_update,omitempty"`
	// domain name
	DomainName string `form:"domain_name" json:"domain_name" xml:"domain_name"`
	// ledger name
	LedgerName string `form:"ledger_name" json:"ledger_name" xml:"ledger_name"`
}

// Validate validates the PermissionDomain type instance.
func (ut *PermissionDomain) Validate() (err error) {
	if ut.DomainName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "domain_name"))
	}
	if ut.LedgerName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ledger_name"))
	}
	return
}

// permissionLedger user type.
type permissionLedger struct {
	// ability to create new account
	AccountAdd *bool `form:"account_add,omitempty" json:"account_add,omitempty" xml:"account_add,omitempty"`
	// ability to give permissions to account globally
	AccountGivePermission *bool `form:"account_give_permission,omitempty" json:"account_give_permission,omitempty" xml:"account_give_permission,omitempty"`
	// ability to remove account
	AccountRemove *bool `form:"account_remove,omitempty" json:"account_remove,omitempty" xml:"account_remove,omitempty"`
	// ability to add new domain
	DomainAdd *bool `form:"domain_add,omitempty" json:"domain_add,omitempty" xml:"domain_add,omitempty"`
	// ability to remove existing domain
	DomainRemove *bool `form:"domain_remove,omitempty" json:"domain_remove,omitempty" xml:"domain_remove,omitempty"`
	// ledger name
	LedgerName *string `form:"ledger_name,omitempty" json:"ledger_name,omitempty" xml:"ledger_name,omitempty"`
	// ability to read peer information
	PeerRead *bool `form:"peer_read,omitempty" json:"peer_read,omitempty" xml:"peer_read,omitempty"`
	// ability to write(operate) peer
	PeerWrite *bool `form:"peer_write,omitempty" json:"peer_write,omitempty" xml:"peer_write,omitempty"`
}

// Validate validates the permissionLedger type instance.
func (ut *permissionLedger) Validate() (err error) {
	if ut.LedgerName == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ledger_name"))
	}
	return
}

// Publicize creates PermissionLedger from permissionLedger
func (ut *permissionLedger) Publicize() *PermissionLedger {
	var pub PermissionLedger
	if ut.AccountAdd != nil {
		pub.AccountAdd = ut.AccountAdd
	}
	if ut.AccountGivePermission != nil {
		pub.AccountGivePermission = ut.AccountGivePermission
	}
	if ut.AccountRemove != nil {
		pub.AccountRemove = ut.AccountRemove
	}
	if ut.DomainAdd != nil {
		pub.DomainAdd = ut.DomainAdd
	}
	if ut.DomainRemove != nil {
		pub.DomainRemove = ut.DomainRemove
	}
	if ut.LedgerName != nil {
		pub.LedgerName = *ut.LedgerName
	}
	if ut.PeerRead != nil {
		pub.PeerRead = ut.PeerRead
	}
	if ut.PeerWrite != nil {
		pub.PeerWrite = ut.PeerWrite
	}
	return &pub
}

// PermissionLedger user type.
type PermissionLedger struct {
	// ability to create new account
	AccountAdd *bool `form:"account_add,omitempty" json:"account_add,omitempty" xml:"account_add,omitempty"`
	// ability to give permissions to account globally
	AccountGivePermission *bool `form:"account_give_permission,omitempty" json:"account_give_permission,omitempty" xml:"account_give_permission,omitempty"`
	// ability to remove account
	AccountRemove *bool `form:"account_remove,omitempty" json:"account_remove,omitempty" xml:"account_remove,omitempty"`
	// ability to add new domain
	DomainAdd *bool `form:"domain_add,omitempty" json:"domain_add,omitempty" xml:"domain_add,omitempty"`
	// ability to remove existing domain
	DomainRemove *bool `form:"domain_remove,omitempty" json:"domain_remove,omitempty" xml:"domain_remove,omitempty"`
	// ledger name
	LedgerName string `form:"ledger_name" json:"ledger_name" xml:"ledger_name"`
	// ability to read peer information
	PeerRead *bool `form:"peer_read,omitempty" json:"peer_read,omitempty" xml:"peer_read,omitempty"`
	// ability to write(operate) peer
	PeerWrite *bool `form:"peer_write,omitempty" json:"peer_write,omitempty" xml:"peer_write,omitempty"`
}

// Validate validates the PermissionLedger type instance.
func (ut *PermissionLedger) Validate() (err error) {
	if ut.LedgerName == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ledger_name"))
	}
	return
}

// permissionRoot user type.
type permissionRoot struct {
	// ability to create new ledgers
	LedgerAdd *bool `form:"ledger_add,omitempty" json:"ledger_add,omitempty" xml:"ledger_add,omitempty"`
	// ability to remove ledgers
	LedgerRemove *bool `form:"ledger_remove,omitempty" json:"ledger_remove,omitempty" xml:"ledger_remove,omitempty"`
}

// Publicize creates PermissionRoot from permissionRoot
func (ut *permissionRoot) Publicize() *PermissionRoot {
	var pub PermissionRoot
	if ut.LedgerAdd != nil {
		pub.LedgerAdd = ut.LedgerAdd
	}
	if ut.LedgerRemove != nil {
		pub.LedgerRemove = ut.LedgerRemove
	}
	return &pub
}

// PermissionRoot user type.
type PermissionRoot struct {
	// ability to create new ledgers
	LedgerAdd *bool `form:"ledger_add,omitempty" json:"ledger_add,omitempty" xml:"ledger_add,omitempty"`
	// ability to remove ledgers
	LedgerRemove *bool `form:"ledger_remove,omitempty" json:"ledger_remove,omitempty" xml:"ledger_remove,omitempty"`
}

// permissions user type.
type permissions struct {
	Asset  []*permissionAsset  `form:"asset,omitempty" json:"asset,omitempty" xml:"asset,omitempty"`
	Domain []*permissionDomain `form:"domain,omitempty" json:"domain,omitempty" xml:"domain,omitempty"`
	Ledger []*permissionLedger `form:"ledger,omitempty" json:"ledger,omitempty" xml:"ledger,omitempty"`
	Root   *permissionRoot     `form:"root,omitempty" json:"root,omitempty" xml:"root,omitempty"`
}

// Validate validates the permissions type instance.
func (ut *permissions) Validate() (err error) {
	if ut.Root == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "root"))
	}
	if ut.Ledger == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ledger"))
	}
	if ut.Domain == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "domain"))
	}
	if ut.Asset == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "asset"))
	}
	for _, e := range ut.Asset {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range ut.Domain {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range ut.Ledger {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Publicize creates Permissions from permissions
func (ut *permissions) Publicize() *Permissions {
	var pub Permissions
	if ut.Asset != nil {
		pub.Asset = make([]*PermissionAsset, len(ut.Asset))
		for i2, elem2 := range ut.Asset {
			pub.Asset[i2] = elem2.Publicize()
		}
	}
	if ut.Domain != nil {
		pub.Domain = make([]*PermissionDomain, len(ut.Domain))
		for i2, elem2 := range ut.Domain {
			pub.Domain[i2] = elem2.Publicize()
		}
	}
	if ut.Ledger != nil {
		pub.Ledger = make([]*PermissionLedger, len(ut.Ledger))
		for i2, elem2 := range ut.Ledger {
			pub.Ledger[i2] = elem2.Publicize()
		}
	}
	if ut.Root != nil {
		pub.Root = ut.Root.Publicize()
	}
	return &pub
}

// Permissions user type.
type Permissions struct {
	Asset  []*PermissionAsset  `form:"asset" json:"asset" xml:"asset"`
	Domain []*PermissionDomain `form:"domain" json:"domain" xml:"domain"`
	Ledger []*PermissionLedger `form:"ledger" json:"ledger" xml:"ledger"`
	Root   *PermissionRoot     `form:"root" json:"root" xml:"root"`
}

// Validate validates the Permissions type instance.
func (ut *Permissions) Validate() (err error) {
	if ut.Root == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "root"))
	}
	if ut.Ledger == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "ledger"))
	}
	if ut.Domain == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "domain"))
	}
	if ut.Asset == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "asset"))
	}
	for _, e := range ut.Asset {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range ut.Domain {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range ut.Ledger {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// signatoryRequest user type.
type signatoryRequest struct {
	// Public key of creator's account
	CreatorPubkey *string `form:"creator_pubkey,omitempty" json:"creator_pubkey,omitempty" xml:"creator_pubkey,omitempty"`
	// Account signatories.
	Signatories []string `form:"signatories,omitempty" json:"signatories,omitempty" xml:"signatories,omitempty"`
	// The signature, which can be verified with pubkey
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
	// Transaction timestamp
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

// Validate validates the signatoryRequest type instance.
func (ut *signatoryRequest) Validate() (err error) {
	if ut.Signatories == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signatories"))
	}
	if ut.CreatorPubkey == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ut.CreatorPubkey != nil {
		if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, *ut.CreatorPubkey); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.creator_pubkey`, *ut.CreatorPubkey, `^[0-9a-zA-Z+/=]+$`))
		}
	}
	if ut.Signature != nil {
		if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, *ut.Signature); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.signature`, *ut.Signature, `^[0-9a-zA-Z+/=]+$`))
		}
	}
	if ut.Timestamp != nil {
		if ok := goa.ValidatePattern(`^[0-9]{1,18}$`, *ut.Timestamp); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, *ut.Timestamp, `^[0-9]{1,18}$`))
		}
	}
	return
}

// Publicize creates SignatoryRequest from signatoryRequest
func (ut *signatoryRequest) Publicize() *SignatoryRequest {
	var pub SignatoryRequest
	if ut.CreatorPubkey != nil {
		pub.CreatorPubkey = *ut.CreatorPubkey
	}
	if ut.Signatories != nil {
		pub.Signatories = ut.Signatories
	}
	if ut.Signature != nil {
		pub.Signature = *ut.Signature
	}
	if ut.Timestamp != nil {
		pub.Timestamp = *ut.Timestamp
	}
	return &pub
}

// SignatoryRequest user type.
type SignatoryRequest struct {
	// Public key of creator's account
	CreatorPubkey string `form:"creator_pubkey" json:"creator_pubkey" xml:"creator_pubkey"`
	// Account signatories.
	Signatories []string `form:"signatories" json:"signatories" xml:"signatories"`
	// The signature, which can be verified with pubkey
	Signature string `form:"signature" json:"signature" xml:"signature"`
	// Transaction timestamp
	Timestamp string `form:"timestamp" json:"timestamp" xml:"timestamp"`
}

// Validate validates the SignatoryRequest type instance.
func (ut *SignatoryRequest) Validate() (err error) {
	if ut.Signatories == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signatories"))
	}
	if ut.CreatorPubkey == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, ut.CreatorPubkey); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.creator_pubkey`, ut.CreatorPubkey, `^[0-9a-zA-Z+/=]+$`))
	}
	if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, ut.Signature); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.signature`, ut.Signature, `^[0-9a-zA-Z+/=]+$`))
	}
	if ok := goa.ValidatePattern(`^[0-9]{1,18}$`, ut.Timestamp); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, ut.Timestamp, `^[0-9]{1,18}$`))
	}
	return
}

// signature user type.
type signature struct {
	// ed25519 public key, which should be used to validate the signature
	Pubkey *string `form:"pubkey,omitempty" json:"pubkey,omitempty" xml:"pubkey,omitempty"`
	// The signature, which can be verified with pubkey
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
}

// Validate validates the signature type instance.
func (ut *signature) Validate() (err error) {
	if ut.Pubkey == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "pubkey"))
	}
	if ut.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Pubkey != nil {
		if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, *ut.Pubkey); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.pubkey`, *ut.Pubkey, `^[0-9a-zA-Z+/=]+$`))
		}
	}
	return
}

// Publicize creates Signature from signature
func (ut *signature) Publicize() *Signature {
	var pub Signature
	if ut.Pubkey != nil {
		pub.Pubkey = *ut.Pubkey
	}
	if ut.Signature != nil {
		pub.Signature = *ut.Signature
	}
	return &pub
}

// Signature user type.
type Signature struct {
	// ed25519 public key, which should be used to validate the signature
	Pubkey string `form:"pubkey" json:"pubkey" xml:"pubkey"`
	// The signature, which can be verified with pubkey
	Signature string `form:"signature" json:"signature" xml:"signature"`
}

// Validate validates the Signature type instance.
func (ut *Signature) Validate() (err error) {
	if ut.Pubkey == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "pubkey"))
	}
	if ut.Signature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, ut.Pubkey); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.pubkey`, ut.Pubkey, `^[0-9a-zA-Z+/=]+$`))
	}
	return
}

// transaction user type.
type transaction struct {
	// transaction creation time
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// creator's signature
	CreatorSignature *string `form:"creator_signature,omitempty" json:"creator_signature,omitempty" xml:"creator_signature,omitempty"`
	// random 4 bytes
	Nonce      *int         `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
	Signatures []*signature `form:"signatures,omitempty" json:"signatures,omitempty" xml:"signatures,omitempty"`
}

// Validate validates the transaction type instance.
func (ut *transaction) Validate() (err error) {
	if ut.CreatorSignature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_signature"))
	}
	if ut.Signatures == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signatures"))
	}
	if ut.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "created_at"))
	}
	if ut.Nonce == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "nonce"))
	}
	if ut.CreatedAt != nil {
		if ok := goa.ValidatePattern(`^[0-9]{1,18}$`, *ut.CreatedAt); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.created_at`, *ut.CreatedAt, `^[0-9]{1,18}$`))
		}
	}
	for _, e := range ut.Signatures {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// Publicize creates Transaction from transaction
func (ut *transaction) Publicize() *Transaction {
	var pub Transaction
	if ut.CreatedAt != nil {
		pub.CreatedAt = *ut.CreatedAt
	}
	if ut.CreatorSignature != nil {
		pub.CreatorSignature = *ut.CreatorSignature
	}
	if ut.Nonce != nil {
		pub.Nonce = *ut.Nonce
	}
	if ut.Signatures != nil {
		pub.Signatures = make([]*Signature, len(ut.Signatures))
		for i2, elem2 := range ut.Signatures {
			pub.Signatures[i2] = elem2.Publicize()
		}
	}
	return &pub
}

// Transaction user type.
type Transaction struct {
	// transaction creation time
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// creator's signature
	CreatorSignature string `form:"creator_signature" json:"creator_signature" xml:"creator_signature"`
	// random 4 bytes
	Nonce      int          `form:"nonce" json:"nonce" xml:"nonce"`
	Signatures []*Signature `form:"signatures" json:"signatures" xml:"signatures"`
}

// Validate validates the Transaction type instance.
func (ut *Transaction) Validate() (err error) {
	if ut.CreatorSignature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_signature"))
	}
	if ut.Signatures == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signatures"))
	}
	if ut.CreatedAt == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "created_at"))
	}

	if ok := goa.ValidatePattern(`^[0-9]{1,18}$`, ut.CreatedAt); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.created_at`, ut.CreatedAt, `^[0-9]{1,18}$`))
	}
	for _, e := range ut.Signatures {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// transactionRequest user type.
type transactionRequest struct {
	// ed25519 public key, which should be used to validate the signature
	Pubkey *string `form:"pubkey,omitempty" json:"pubkey,omitempty" xml:"pubkey,omitempty"`
	// The signature, which can be verified with pubkey
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
	// Transaction timestamp
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

// Validate validates the transactionRequest type instance.
func (ut *transactionRequest) Validate() (err error) {
	if ut.Pubkey == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "pubkey"))
	}
	if ut.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ut.Pubkey != nil {
		if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, *ut.Pubkey); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.pubkey`, *ut.Pubkey, `^[0-9a-zA-Z+/=]+$`))
		}
	}
	if ut.Timestamp != nil {
		if ok := goa.ValidatePattern(`[0-9]{1,18}`, *ut.Timestamp); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, *ut.Timestamp, `[0-9]{1,18}`))
		}
	}
	return
}

// Publicize creates TransactionRequest from transactionRequest
func (ut *transactionRequest) Publicize() *TransactionRequest {
	var pub TransactionRequest
	if ut.Pubkey != nil {
		pub.Pubkey = *ut.Pubkey
	}
	if ut.Signature != nil {
		pub.Signature = *ut.Signature
	}
	if ut.Timestamp != nil {
		pub.Timestamp = *ut.Timestamp
	}
	return &pub
}

// TransactionRequest user type.
type TransactionRequest struct {
	// ed25519 public key, which should be used to validate the signature
	Pubkey string `form:"pubkey" json:"pubkey" xml:"pubkey"`
	// The signature, which can be verified with pubkey
	Signature string `form:"signature" json:"signature" xml:"signature"`
	// Transaction timestamp
	Timestamp string `form:"timestamp" json:"timestamp" xml:"timestamp"`
}

// Validate validates the TransactionRequest type instance.
func (ut *TransactionRequest) Validate() (err error) {
	if ut.Pubkey == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "pubkey"))
	}
	if ut.Signature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ok := goa.ValidatePattern(`^[0-9a-zA-Z+/=]+$`, ut.Pubkey); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.pubkey`, ut.Pubkey, `^[0-9a-zA-Z+/=]+$`))
	}
	if ok := goa.ValidatePattern(`[0-9]{1,18}`, ut.Timestamp); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, ut.Timestamp, `[0-9]{1,18}`))
	}
	return
}

// updateAccountRequest user type.
type updateAccountRequest struct {
	MetaTransaction *transactionRequest `form:"meta_transaction,omitempty" json:"meta_transaction,omitempty" xml:"meta_transaction,omitempty"`
	// account's username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Validate validates the updateAccountRequest type instance.
func (ut *updateAccountRequest) Validate() (err error) {
	if ut.Username == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "username"))
	}
	if ut.MetaTransaction == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "meta_transaction"))
	}
	if ut.MetaTransaction != nil {
		if err2 := ut.MetaTransaction.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Username != nil {
		if ok := goa.ValidatePattern(`^[a-zA-Z0-9\_\-\.]{4,32}$`, *ut.Username); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.username`, *ut.Username, `^[a-zA-Z0-9\_\-\.]{4,32}$`))
		}
	}
	return
}

// Publicize creates UpdateAccountRequest from updateAccountRequest
func (ut *updateAccountRequest) Publicize() *UpdateAccountRequest {
	var pub UpdateAccountRequest
	if ut.MetaTransaction != nil {
		pub.MetaTransaction = ut.MetaTransaction.Publicize()
	}
	if ut.Username != nil {
		pub.Username = *ut.Username
	}
	return &pub
}

// UpdateAccountRequest user type.
type UpdateAccountRequest struct {
	MetaTransaction *TransactionRequest `form:"meta_transaction" json:"meta_transaction" xml:"meta_transaction"`
	// account's username
	Username string `form:"username" json:"username" xml:"username"`
}

// Validate validates the UpdateAccountRequest type instance.
func (ut *UpdateAccountRequest) Validate() (err error) {
	if ut.Username == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "username"))
	}
	if ut.MetaTransaction == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "meta_transaction"))
	}
	if ut.MetaTransaction != nil {
		if err2 := ut.MetaTransaction.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ok := goa.ValidatePattern(`^[a-zA-Z0-9\_\-\.]{4,32}$`, ut.Username); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.username`, ut.Username, `^[a-zA-Z0-9\_\-\.]{4,32}$`))
	}
	return
}

// updateCurrencyRequest user type.
type updateCurrencyRequest struct {
	// Public key of creator's account
	CreatorPubkey *string `form:"creator_pubkey,omitempty" json:"creator_pubkey,omitempty" xml:"creator_pubkey,omitempty"`
	// currency's description
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The signature, which can be verified with pubkey
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
	// Transaction timestamp
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

// Validate validates the updateCurrencyRequest type instance.
func (ut *updateCurrencyRequest) Validate() (err error) {
	if ut.Description == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "description"))
	}
	if ut.CreatorPubkey == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ut.Timestamp != nil {
		if ok := goa.ValidatePattern(`[0-9]{1,18}`, *ut.Timestamp); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, *ut.Timestamp, `[0-9]{1,18}`))
		}
	}
	return
}

// Publicize creates UpdateCurrencyRequest from updateCurrencyRequest
func (ut *updateCurrencyRequest) Publicize() *UpdateCurrencyRequest {
	var pub UpdateCurrencyRequest
	if ut.CreatorPubkey != nil {
		pub.CreatorPubkey = *ut.CreatorPubkey
	}
	if ut.Description != nil {
		pub.Description = *ut.Description
	}
	if ut.Signature != nil {
		pub.Signature = *ut.Signature
	}
	if ut.Timestamp != nil {
		pub.Timestamp = *ut.Timestamp
	}
	return &pub
}

// UpdateCurrencyRequest user type.
type UpdateCurrencyRequest struct {
	// Public key of creator's account
	CreatorPubkey string `form:"creator_pubkey" json:"creator_pubkey" xml:"creator_pubkey"`
	// currency's description
	Description string `form:"description" json:"description" xml:"description"`
	// The signature, which can be verified with pubkey
	Signature string `form:"signature" json:"signature" xml:"signature"`
	// Transaction timestamp
	Timestamp string `form:"timestamp" json:"timestamp" xml:"timestamp"`
}

// Validate validates the UpdateCurrencyRequest type instance.
func (ut *UpdateCurrencyRequest) Validate() (err error) {
	if ut.Description == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "description"))
	}
	if ut.CreatorPubkey == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ok := goa.ValidatePattern(`[0-9]{1,18}`, ut.Timestamp); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, ut.Timestamp, `[0-9]{1,18}`))
	}
	return
}

// updateQuorumRequest user type.
type updateQuorumRequest struct {
	// Public key of creator's account
	CreatorPubkey *string `form:"creator_pubkey,omitempty" json:"creator_pubkey,omitempty" xml:"creator_pubkey,omitempty"`
	// Minimum number of signatures required to issue valid transaction.
	Quorum *int `form:"quorum,omitempty" json:"quorum,omitempty" xml:"quorum,omitempty"`
	// The signature, which can be verified with pubkey
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
	// Transaction timestamp
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
}

// Validate validates the updateQuorumRequest type instance.
func (ut *updateQuorumRequest) Validate() (err error) {
	if ut.Quorum == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "quorum"))
	}
	if ut.CreatorPubkey == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ut.Timestamp != nil {
		if ok := goa.ValidatePattern(`[0-9]{1,18}`, *ut.Timestamp); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, *ut.Timestamp, `[0-9]{1,18}`))
		}
	}
	return
}

// Publicize creates UpdateQuorumRequest from updateQuorumRequest
func (ut *updateQuorumRequest) Publicize() *UpdateQuorumRequest {
	var pub UpdateQuorumRequest
	if ut.CreatorPubkey != nil {
		pub.CreatorPubkey = *ut.CreatorPubkey
	}
	if ut.Quorum != nil {
		pub.Quorum = *ut.Quorum
	}
	if ut.Signature != nil {
		pub.Signature = *ut.Signature
	}
	if ut.Timestamp != nil {
		pub.Timestamp = *ut.Timestamp
	}
	return &pub
}

// UpdateQuorumRequest user type.
type UpdateQuorumRequest struct {
	// Public key of creator's account
	CreatorPubkey string `form:"creator_pubkey" json:"creator_pubkey" xml:"creator_pubkey"`
	// Minimum number of signatures required to issue valid transaction.
	Quorum int `form:"quorum" json:"quorum" xml:"quorum"`
	// The signature, which can be verified with pubkey
	Signature string `form:"signature" json:"signature" xml:"signature"`
	// Transaction timestamp
	Timestamp string `form:"timestamp" json:"timestamp" xml:"timestamp"`
}

// Validate validates the UpdateQuorumRequest type instance.
func (ut *UpdateQuorumRequest) Validate() (err error) {

	if ut.CreatorPubkey == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "creator_pubkey"))
	}
	if ut.Signature == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "signature"))
	}
	if ut.Timestamp == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "timestamp"))
	}
	if ok := goa.ValidatePattern(`[0-9]{1,18}`, ut.Timestamp); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`response.timestamp`, ut.Timestamp, `[0-9]{1,18}`))
	}
	return
}
