// Code generated by goagen v1.2.0, DO NOT EDIT.
//
// API "Iroha-Gateway Server": account Resource Client
//
// Command:
// $ goagen
// --design=github.com/soramitsu/iroha-gateway/design
// --out=$(GOPATH)/src/github.com/soramitsu/iroha-gateway
// --version=v1.2.0

package client

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
)

// AddAccountPath computes a request path to the add action of account.
func AddAccountPath() string {

	return fmt.Sprintf("/accounts")
}

// add an account
func (c *Client) AddAccount(ctx context.Context, path string, payload *AddAccountRequest, contentType string) (*http.Response, error) {
	req, err := c.NewAddAccountRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewAddAccountRequest create the request corresponding to the add action endpoint of the account resource.
func (c *Client) NewAddAccountRequest(ctx context.Context, path string, payload *AddAccountRequest, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	return req, nil
}

// DeleteByUUIDAccountPath computes a request path to the deleteByUUID action of account.
func DeleteByUUIDAccountPath(uuid string) string {
	param0 := uuid

	return fmt.Sprintf("/accounts/%s", param0)
}

// delete an account
func (c *Client) DeleteByUUIDAccount(ctx context.Context, path string, payload *DeleteAccountRequest, contentType string) (*http.Response, error) {
	req, err := c.NewDeleteByUUIDAccountRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDeleteByUUIDAccountRequest create the request corresponding to the deleteByUUID action endpoint of the account resource.
func (c *Client) NewDeleteByUUIDAccountRequest(ctx context.Context, path string, payload *DeleteAccountRequest, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("DELETE", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	return req, nil
}

// DeleteByUsernameAccountPath computes a request path to the deleteByUsername action of account.
func DeleteByUsernameAccountPath(domainURI string, username string) string {
	param0 := domainURI
	param1 := username

	return fmt.Sprintf("/domains/%s/accounts/%s", param0, param1)
}

// delete an account by account's domain and username
func (c *Client) DeleteByUsernameAccount(ctx context.Context, path string, payload *DeleteAccountRequest, contentType string) (*http.Response, error) {
	req, err := c.NewDeleteByUsernameAccountRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDeleteByUsernameAccountRequest create the request corresponding to the deleteByUsername action endpoint of the account resource.
func (c *Client) NewDeleteByUsernameAccountRequest(ctx context.Context, path string, payload *DeleteAccountRequest, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("DELETE", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	return req, nil
}

// DeleteByUsernameFromDefaultDomainAccountPath computes a request path to the deleteByUsernameFromDefaultDomain action of account.
func DeleteByUsernameFromDefaultDomainAccountPath(username string) string {
	param0 := username

	return fmt.Sprintf("/domains/default/accounts/%s", param0)
}

// delete an account by account's username from default domain
func (c *Client) DeleteByUsernameFromDefaultDomainAccount(ctx context.Context, path string, payload *DeleteAccountRequest, contentType string) (*http.Response, error) {
	req, err := c.NewDeleteByUsernameFromDefaultDomainAccountRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDeleteByUsernameFromDefaultDomainAccountRequest create the request corresponding to the deleteByUsernameFromDefaultDomain action endpoint of the account resource.
func (c *Client) NewDeleteByUsernameFromDefaultDomainAccountRequest(ctx context.Context, path string, payload *DeleteAccountRequest, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("DELETE", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	return req, nil
}

// GetAllAccountPath computes a request path to the getAll action of account.
func GetAllAccountPath() string {

	return fmt.Sprintf("/accounts")
}

// get all accounts
func (c *Client) GetAllAccount(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewGetAllAccountRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetAllAccountRequest create the request corresponding to the getAll action endpoint of the account resource.
func (c *Client) NewGetAllAccountRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetByUUIDAccountPath computes a request path to the getByUUID action of account.
func GetByUUIDAccountPath(uuid string) string {
	param0 := uuid

	return fmt.Sprintf("/accounts/%s", param0)
}

// get an account by account's UUID
func (c *Client) GetByUUIDAccount(ctx context.Context, path string, isCommitted *bool) (*http.Response, error) {
	req, err := c.NewGetByUUIDAccountRequest(ctx, path, isCommitted)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetByUUIDAccountRequest create the request corresponding to the getByUUID action endpoint of the account resource.
func (c *Client) NewGetByUUIDAccountRequest(ctx context.Context, path string, isCommitted *bool) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if isCommitted != nil {
		tmp30 := strconv.FormatBool(*isCommitted)
		values.Set("is_committed", tmp30)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetByUsernameAccountPath computes a request path to the getByUsername action of account.
func GetByUsernameAccountPath(domainURI string, username string) string {
	param0 := domainURI
	param1 := username

	return fmt.Sprintf("/domains/%s/accounts/%s", param0, param1)
}

// get an account by account's domain and username
func (c *Client) GetByUsernameAccount(ctx context.Context, path string, isCommitted *bool) (*http.Response, error) {
	req, err := c.NewGetByUsernameAccountRequest(ctx, path, isCommitted)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetByUsernameAccountRequest create the request corresponding to the getByUsername action endpoint of the account resource.
func (c *Client) NewGetByUsernameAccountRequest(ctx context.Context, path string, isCommitted *bool) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if isCommitted != nil {
		tmp31 := strconv.FormatBool(*isCommitted)
		values.Set("is_committed", tmp31)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetByUsernameFromDefaultDomainAccountPath computes a request path to the getByUsernameFromDefaultDomain action of account.
func GetByUsernameFromDefaultDomainAccountPath(username string) string {
	param0 := username

	return fmt.Sprintf("/domains/default/accounts/%s", param0)
}

// get an account by account's username from default domain
func (c *Client) GetByUsernameFromDefaultDomainAccount(ctx context.Context, path string, isCommitted *bool) (*http.Response, error) {
	req, err := c.NewGetByUsernameFromDefaultDomainAccountRequest(ctx, path, isCommitted)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewGetByUsernameFromDefaultDomainAccountRequest create the request corresponding to the getByUsernameFromDefaultDomain action endpoint of the account resource.
func (c *Client) NewGetByUsernameFromDefaultDomainAccountRequest(ctx context.Context, path string, isCommitted *bool) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	values := u.Query()
	if isCommitted != nil {
		tmp32 := strconv.FormatBool(*isCommitted)
		values.Set("is_committed", tmp32)
	}
	u.RawQuery = values.Encode()
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// UpdateByUUIDAccountPath computes a request path to the updateByUUID action of account.
func UpdateByUUIDAccountPath(uuid string) string {
	param0 := uuid

	return fmt.Sprintf("/accounts/%s", param0)
}

// update an account by account's uuid
func (c *Client) UpdateByUUIDAccount(ctx context.Context, path string, payload *UpdateAccountRequest, contentType string) (*http.Response, error) {
	req, err := c.NewUpdateByUUIDAccountRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUpdateByUUIDAccountRequest create the request corresponding to the updateByUUID action endpoint of the account resource.
func (c *Client) NewUpdateByUUIDAccountRequest(ctx context.Context, path string, payload *UpdateAccountRequest, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	return req, nil
}

// UpdateByUsernameAccountPath computes a request path to the updateByUsername action of account.
func UpdateByUsernameAccountPath(domainURI string, username string) string {
	param0 := domainURI
	param1 := username

	return fmt.Sprintf("/domains/%s/accounts/%s", param0, param1)
}

// update an account by account's domain and username
func (c *Client) UpdateByUsernameAccount(ctx context.Context, path string, payload *UpdateAccountRequest, contentType string) (*http.Response, error) {
	req, err := c.NewUpdateByUsernameAccountRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUpdateByUsernameAccountRequest create the request corresponding to the updateByUsername action endpoint of the account resource.
func (c *Client) NewUpdateByUsernameAccountRequest(ctx context.Context, path string, payload *UpdateAccountRequest, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	return req, nil
}

// UpdateByUsernameFromDefaultDomainAccountPath computes a request path to the updateByUsernameFromDefaultDomain action of account.
func UpdateByUsernameFromDefaultDomainAccountPath(username string) string {
	param0 := username

	return fmt.Sprintf("/domains/default/accounts/%s", param0)
}

// update an account by account's username from default domain
func (c *Client) UpdateByUsernameFromDefaultDomainAccount(ctx context.Context, path string, payload *UpdateAccountRequest, contentType string) (*http.Response, error) {
	req, err := c.NewUpdateByUsernameFromDefaultDomainAccountRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUpdateByUsernameFromDefaultDomainAccountRequest create the request corresponding to the updateByUsernameFromDefaultDomain action endpoint of the account resource.
func (c *Client) NewUpdateByUsernameFromDefaultDomainAccountRequest(ctx context.Context, path string, payload *UpdateAccountRequest, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	return req, nil
}
